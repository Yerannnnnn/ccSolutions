寻找两个有序数组的中位数

给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。

请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。

你可以假设 nums1 和 nums2 不会同时为空。

示例 1:

nums1 = [1, 3]
nums2 = [2]

则中位数是 2.0
示例 2:

nums1 = [1, 2]
nums2 = [3, 4]

则中位数是 (2 + 3)/2 = 2.5


来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



# 这个问题到底需要我们求什么？
这道题其实思路想通了很简单。什么是两个数组的中位数？就是两个按有序合并后排在中间的那个数。这样这个问题就可以转化为求第k小的那个数（如果合并后数组长度是奇数的话，偶数那就是求第k小和第k+1小那两个数）。
举个例子：
{1,2}与{0}的中位数就是合并后{0,1,2}中的中间那个数即中位数是“1”，它可以转化为求第2小的数。
{1,2}与{0,5}的中位数就是合并后{0,1,2,5}中的中间那两个数求平均(1+2)/2.0 = 1.5，它可以转化为求第2小和第3小的平均。
现在问题来了：如何求两个有序数组有序合并后第k小的数？

# 如何求两个有序数组有序合并后的第k小的数？
很自然可以想到用两个双指针从两个数组头遍历模拟合并找到第k小数。这个很容易也很简单。但是它复杂度是O(m+n)，不符合题目中的O(log(m+n))的需求。

那么我们可不可以改进它呢？因为它是有序数组所以我们可以利用**“有序”**这个特性可以不逐步逐步的从头遍历，而是最好每次可以跳开一大段这样就能节省很多时间。
比如：我想找arr1 = {1,2}和arr2 = {0,5}合并后第k小的数。这意味着我只需要从两个数组找k个超级小的数就达到目的了。

规律1：并且这k个数一定要么是从arr1中的头几个取，要么是从arr2中头几个取。因为越到后面数字越大。不存在说某个数组头几个数不是前k小中的但是后几个数是属于前k小的。

规律2；合并后数组中的前k小的数要么是从arr1中至少取前k/2个数，要么是从arr2中取前k/2个数。
上面这两个规律有什么意义呢？
我们可以先暂时做出2个猜测。

猜测1：最终合并后的数组中前k小的数是包含arr1中所取前k/2个数

猜测2：最终合并后的数组中前k小的数是包含arr2中取k/2个数

利用规律1和规律2我们可以知道猜测1和猜测2中有一个一定是成立的。这样子我们就一下子知道了合并后数组中前k/2个数是哪些数了，而我们是想求前k个数。所以一下子减少了一半的计算量时间复杂度是O(log(k))的。

问题又来了，如何知道“猜测1”与“猜测2”哪个是对的？

其实非常简单，唯一的判断标准就是“较小的那段一定是属于合并后数组中前k小”。
很自然的想到我们只需判断arr1中第k/2个数与arr2中第k/2个数的大小。较小的那段一定属于前k个数中的一部分。比如：{0,1...}与{2,3....}，我们通过比较两个数组中第2个数大小后可以100%确定{0,1}一定是属于前k小的。就这样不断重复，每次排除k/2个数，然后就可以找到合并后数组的前k小所有数。从而可以找到第k小数。

作者：varyshare
链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/cong-fa-ming-de-jiao-du-kan-gao-xiao-yi-dong-ti-ji/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
